
import Identifier from "@mcbe/identifier";
import ID from "@mcbe/identifier/id";

import { CommandResult, command } from "@mcbe/system_server";
import { Lang } from "@mcbe/lang";
import ruakr_const = require("@mcbe/ruakr_const");

/** objective length limit */
export const OBJECTIVE_MAX_LENGTH = ruakr_const.OBJECTIVE_MAX_LENGTH;
/** 
 * scoreboard character limit
 * this limitations is needed to parse from message
 */
export const SCOREBOARD_UNUSABLE_CHARACTER = ruakr_const.SCOREBOARD_UNUSABLE_CHARACTER;

/**
 * scoreboard character limit with regexp
 * just to capture one character
 */
export const SCOREBOARD_UNUSABLE_REGEXP = ruakr_const.SCOREBOARD_UNUSABLE_REGEXP;

declare global
{
    interface Error
    {
        statusCode?:number;
    }
}

export function commandError(res:CommandResult):Error
{
    const err = Error(res.statusMessage);
    err.statusCode = res.statusCode;
    return err;
}

/** Objective result for scoreboard */
export interface Objective
{
    id:string;
    displayName:string;
    type:string;
}

/** Score result for 'scoreboard players list [playername]', just map-like object */
export type Scores = {[key:string]:number};


export const scoreboard = {
    /**
     * check objective name has invalid character
     * It limits more character to parse from message
     * limited characters are defined as SCOREBOARD_UNUSABLE_CHARACTER
     */
    testInvalidCharacter(name:string):void
    {
        if (SCOREBOARD_UNUSABLE_REGEXP.test(name))
        {
            const msg = 'Invalid character contains: '+name;
            console.error(msg);
            throw Error(msg);
        }
    },

    /**
     * check objective name has invalid character
     * It limits more character to parse from message
     * it calls testInvalidCharacter internally
     * and check score length for objective names
     */
    testInvalid(name:string):void
    {
        scoreboard.testInvalidCharacter(name);
        if (name.length > OBJECTIVE_MAX_LENGTH)
        {
            const msg = `${name} is too long(${name.length})`;
            console.error(msg);
            throw Error(msg);
        }
    },

    players:{
        /** get all player list from scoreboard */
        async list():Promise<string[]>
        {
            const res = await command('scoreboard players list');
            const lang = await Lang.onLoad;
            if (res.statusCode !== 0)
            {
                if (lang.commands.scoreboard_players_list_empty.reset().exec(res.statusMessage))
                {
                    return [];
                }
                throw commandError(res);
            }
            const msg = res.statusMessage;
            const nextLine = msg.indexOf('\n');
            return msg.substr(nextLine+1).split(', ');
        },
        /**
         * get all scores from player
         * Scores is just map-like object
         */
        async listOf(player:string):Promise<Scores>
        {
            scoreboard.testInvalidCharacter(player);
            const res = await command(`scoreboard players list "${player}"`);
            const lang = await Lang.onLoad;
            if (res.statusCode !== 0)
            {
                if (lang.commands.scoreboard_players_list_player_empty.reset().exec(res.statusMessage))
                {
                    return {};
                }
                throw commandError(res);
            }
            const regexp = lang.commands.scoreboard_players_list_player_entry;
            const values:Scores = {};
            let arr:string[]|null;
            regexp.reset();
            while (arr = regexp.exec(res.statusMessage))
            {
                values[arr[1]] = (arr[0] as any) | 0;
            }
            return values;
        },
        /**
         * get score from player and objective
         * it can return undefined
         * It limits player name character to parse from message
         * limited characters are defined as SCOREBOARD_UNUSABLE_CHARACTER
         */
        async get(player:string, objective:string):Promise<number|undefined>
        {
            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players test "${player}" "${objective}" *`);
            if (res.statusCode !== 0) return undefined;
            const lang = await Lang.onLoad;
            const regres = lang.commands.scoreboard_players_test_success.reset().exec(res.statusMessage);
            if (!regres) throw commandError(res);
            return parseInt(regres[0]);
        },    
        /**
         * reset score with player and objective
         * if objective is not defined, it will reset all scores of player
         * It limits player name character to parse from message
         * limited characters are defined as SCOREBOARD_UNUSABLE_CHARACTER
         */
        async reset(player:string, objective?:string):Promise<void>
        {
            scoreboard.testInvalidCharacter(player);
            let cmd = `scoreboard players reset "${player}"`;
            if (objective)
            {
                scoreboard.testInvalid(objective);
                cmd += ' "';
                cmd += objective;
                cmd += '"';
            }
            const res = await command(cmd);
            if (res.statusCode !== 0)
            {
                console.error(`${cmd} ${res.statusMessage}`);
            }
        },
        /** set score with player and objective */
        async set(player:string, objective:string, count:number):Promise<void>
        {
            const icount = count |0;
            if (count !== icount)
            {
                throw Error(`scoreboard players set ${player} ${objective} ${count}: count must be integer`);
            }
            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players set "${player}" "${objective}" ${icount}`);
            if (res.statusCode !== 0) throw commandError(res);
        },
        /** add score with player and objective */
        async add(player:string, objective:string, count:number):Promise<number>
        {
            const icount = count |0;
            if (count !== icount)
            {
                throw Error(`scoreboard players set ${player} ${objective} ${count}: count must be integer`);
            }

            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players add "${player}" "${objective}" ${icount}`);
            if (res.statusCode !== 0) throw commandError(res);
            const lang = await Lang.onLoad;
            const regres = lang.commands.scoreboard_players_add_success.reset().exec(res.statusMessage);
            if (!regres) throw commandError(res);
            return parseInt(regres[3]);
        },
        /** remove score with player and objective */
        async remove(player:string, objective:string, count:number):Promise<number>
        {
            const icount = count |0;
            if (count !== icount)
            {
                throw Error(`scoreboard players set ${player} ${objective} ${count}: count must be integer`);
            }

            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players remove "${player}" "${objective}" ${icount}`);
            if (res.statusCode !== 0) throw commandError(res);
            const lang = await Lang.onLoad;
            const regres = lang.commands.scoreboard_players_remove_success.reset().exec(res.statusMessage);
            if (!regres) throw commandError(res);
            return parseInt(regres[3]);
        }
    },
    objectives: {
        /** get all objective list from scoreboard */
        async list():Promise<Objective[]>
        {
            const list = await command(`scoreboard objectives list`);
            const lang = await Lang.onLoad;
            const reg = lang.commands.scoreboard_objectives_list_entry;
            const message = list.statusMessage;
        
            reg.reset();
        
            const objectives:Objective[] = [];
            let res:string[]|null;
            while (res = reg.exec(message))
            {
                const id = res[0];
                const displayName = res[1];
                const type = res[2];
                objectives.push({id, displayName, type});
            }
            return objectives;
        },
        
        /** create objective */
        add(objective:string):Promise<CommandResult>
        {
            scoreboard.testInvalid(objective);
            return command(`scoreboard objectives add "${objective}" dummy`);
        },
        
        /** remove objective */
        remove(objective:string):Promise<CommandResult>
        {
            scoreboard.testInvalid(objective);
            return command(`scoreboard objectives remove "${objective}"`);
        },
        
        /** display objective to list or sidebar */
        setDisplay(type:'list'|'sidebar', objective?:string, order?:'ascending'|'descending'):Promise<CommandResult>
        {
            let cmd = `scoreboard objectives setdisplay ${type}`;
            if (objective)
            {
                scoreboard.testInvalid(objective);
                cmd += ' "';
                cmd += objective;
                cmd += '"';
                if (order)
                {
                    cmd += ' ';
                    cmd += 'order';
                }
            }
            return command(cmd);
        },
        
        /**
         * clear all objective
         * it will repeat remove internally
         */
        async clear():Promise<void>
        {
            const list = await scoreboard.objectives.list();
            for (const obj of list)
            {
                scoreboard.objectives.remove(obj.id);
            }
        }
    }
};

/** display message */
export function say(message:any):Promise<CommandResult>
{
    return command(`say ${message}`);
}

/** 'list' command result */
export interface ListResult extends CommandResult
{
    currentPlayer:number;
    maxPlayer:number;

    /** comma+space seperated player list */
    players:string;
}

/** list of players */
export async function list():Promise<string[]>
{    
    const res:ListResult = await command<ListResult>('list');
    if (res.statusCode !== 0)
    {
        console.error('list '+res.statusMessage);
        return [];
    }
    return res.players.split(', ');
}

/** kill user with name */
export async function kill(name:string):Promise<boolean>
{
    let cmd = `kill "${name}"`;
    const res = await command(cmd);
    return res.statusCode === 0;
}

/** fill blocks with range, it can fill 32768(0x8000) blocks at one */
export async function fill(from:VectorXYZ, to:VectorXYZ, type:Identifier, dataId?:number):Promise<boolean>
{
    let cmd = `fill ${from.x} ${from.y} ${from.z} ${to.x} ${to.y} ${to.z} ${type}`;
    if (dataId !== undefined)
    {
        cmd += ' ';
        cmd += dataId;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`fill ${from.x} ${from.y} ${from.z} ${type.mini} ${res.statusMessage}`);
        return false;
    }
    return true;
}

/**
 * fill blocks with rance, it can fill unlimited count
 * it repeats 'fill' internally
 */
export async function fillx(from:VectorXYZ, to:VectorXYZ, type:Identifier, dataId?:number):Promise<void>
{
    const minx:number = Math.min(from.x, to.x);
    const miny:number = Math.min(from.y, to.y);
    const minz:number = Math.min(from.z, to.z);
    const maxx:number = Math.max(from.x, to.x) + 1;
    const maxy:number = Math.max(from.y, to.y) + 1;
    const maxz:number = Math.max(from.z, to.z) + 1;
    let extra = type+'';
    if (dataId !== undefined)
    {
        extra += ' ';
        extra += dataId;
    }

    const proms:Promise<CommandResult>[] = [];

    for (let z = minz; z < maxz; z+= 0x20)
    {
        const zto = Math.min(maxz - z, 0x20) + z - 1;
        for (let y = miny; y < maxy; y+= 0x20)
        {
            const yto = Math.min(maxy - y, 0x20) + y - 1;
            for (let x = minx; x < maxx; x+= 0x20)
            {
                const xto = Math.min(maxx - x, 0x20) + x - 1;
                proms.push(command(`fill ${x} ${y} ${z} ${xto} ${yto} ${zto} ${extra}`));
            }
        }
    }
    await Promise.all(proms);
}

/**
 * fill blocks with range, it can fill 32768(0x8000) blocks at one
 * it uses 'execute .. fill'
 * If player out, it will fail
 */
export async function fillBy(player:string, from:VectorXYZ, to:VectorXYZ, type:Identifier, dataId?:number):Promise<boolean>
{
    let cmd = `execute "${player}" ~ ~ ~ fill ${from.x} ${from.y} ${from.z} ${to.x} ${to.y} ${to.z} ${type}`;
    if (dataId !== undefined)
    {
        cmd += ' ';
        cmd += dataId;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`fillBy ${player} ${from.x} ${from.y} ${from.z} ${type.mini} ${res.statusMessage}`);
        return false;
    }
    return true;
}

/**
 * replace blocks with range, it can fill 32768(0x8000) blocks at one
 * 'fill .. replace'
 */
export async function fillReplace(from:VectorXYZ, to:VectorXYZ, 
    type:Identifier, dataId:number, 
    typeFrom:Identifier, dataIdFrom:number):Promise<number>
{
    let cmd = `fill ${from.x} ${from.y} ${from.z} ${to.x} ${to.y} ${to.z} ${type} ${dataId} replace ${typeFrom} ${dataIdFrom}`;
    const res = await command(cmd);
    const lang = await Lang.onLoad;
    lang.commands.fill_success.reset();
    const regres = lang.commands.fill_success.reset().exec(res.statusMessage);
    if (res.statusCode !== 0)
    {
        if (regres && regres[0] === '0') return 0;
        console.error(`fillReplace(${from}, ${to}, ${type}, ${typeFrom}) ${res.statusMessage}`);
        return -1;
    }
    if (!regres) return 0;
    return +regres[0];
}

/**
 * replace blocks with range, it can fill 32768(0x8000) blocks at one
 * 'execute .. fill .. replace'
 * If player out, it will fail
 */
export async function fillReplaceBy(player:string, from:VectorXYZ, to:VectorXYZ, 
    type:Identifier, dataId:number, 
    typeFrom:Identifier, dataIdFrom:number):Promise<boolean>
{
    let cmd = `execute "${player}" ~ ~ ~ fill ${from.x} ${from.y} ${from.z} ${to.x} ${to.y} ${to.z} ${type} ${dataId} replace ${typeFrom} ${dataIdFrom}`;
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`fillReplaceBy(${player}, ${from}, ${to}, ${type}, ${typeFrom}) ${res.statusMessage}`);
        return false;
    }
    return true;
}

/** test block at position */
export async function testforblock(pos:VectorXYZ, type:Identifier):Promise<boolean>
{
    const res = await command(`testforblock ${pos.x} ${pos.y} ${pos.z} ${type}`);
    return res.statusCode === 0;
}

/**
 * test block at position with player
 * it uses 'execute .. testforblock'
 * If player out, it will fail
 */
export async function testforblockBy(player:string, pos:VectorXYZ, type:Identifier):Promise<boolean>
{
    const res = await command(`execute "${player}" ~ ~ ~ testforblock ${pos.x} ${pos.y} ${pos.z} ${type}`);
    return res.statusCode === 0;
}

/** set block at position */
export async function setblock(to:VectorXYZ, type:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `setblock ${to.x} ${to.y} ${to.z} ${type}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0 ';
        cmd += option;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`setblock(${to.x},${to.y},${to.z},${type}) ${res.statusMessage}`);
        return false;
    }
    return true;
}

/**
 * replace block at position with player
 * it uses fillReplace internally
 */
export async function replaceBlock(pos:VectorXYZ, from:Identifier, to:Identifier):Promise<boolean>
{
    try
    {
        const count = await fillReplace(pos, pos, to, 0, from, 0);;
        return count !== 0;
    }
    catch (err)
    {
        return false;
    }
}

/**
 * set block at position with player
 * it uses 'execute .. setblock'
 * If player out, it will fail
 */
export async function setBlockBy(player:string, to:VectorXYZ, type:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `execute "${player}" ~ ~ ~ setblock ${to.x} ${to.y} ${to.z} ${type}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0';
        cmd += ' ';
        cmd += option;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`setBlockBy (${player},${to.x},${to.y},${to.z},${type}) ${res.statusMessage}`);
        return false;
    }
    return true;
}

/**
 * replace block at position with player
 * it uses fillReplace internally
 * If player out, it will fail
 */
export function replaceBlockBy(player:string, pos:VectorXYZ, from:Identifier, to:Identifier):Promise<boolean>
{
    return fillReplaceBy(player, pos, pos, to, 0, from, 0);
}

/**
 * set block at position
 * it's same with setBlock but no log
 */
export async function setblockWithoutError(pos:VectorXYZ, block:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `setblock ${pos.x} ${pos.y} ${pos.z} ${block}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0';
        cmd += ' ';
        cmd += option;
    }
    const res = await command(cmd);
    return res.statusCode === 0;
}

/**
 * set block at position with player
 * it's same with setBlockBy but no log
 */
export async function setblockByWithoutError(player:string, to:VectorXYZ, type:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `execute "${player}" ~ ~ ~ setblock ${to.x} ${to.y} ${to.z} ${type}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0';
        cmd += ' ';
        cmd += option;
    }
    const res = await command(cmd);
    return res.statusCode === 0;
}

function coordForTp(num:number):string
{
    const str = num.toString();
    if (!str.indexOf('.')) return str + '.0';
    else return str;
}

/** teleport user */
export async function tp(name:string, to:VectorXYZ):Promise<boolean>
{
    const res = await command(`tp "${name}" ${coordForTp(to.x)} ${coordForTp(to.y)} ${coordForTp(to.z)}`);
    return res.statusCode === 0;
}

/** set title fade times to user */
export async function titleTimes(name:string, fadeIn:number, stay:number, fadeOut:number):Promise<boolean>
{
    const res = await command(`title "${name}" times ${fadeIn} ${stay} ${fadeOut}`);
    return res.statusCode === 0;
}

/** reset title fade times to user */
export async function titleReset(name:string):Promise<boolean>
{
    const res = await command(`title "${name}" reset`);
    return res.statusCode === 0;
}

/** display title to user */
export async function title(name:string, type:'title'|'subtitle'|'actionbar', message:string):Promise<boolean>
{
    const res = await command(`title "${name}" ${type} ${message}`);
    return res.statusCode === 0;
}

/**
 * title to all
 * it uses 'title @a ..' command internally
 */
export async function titleAll(type:'title'|'subtitle'|'actionbar', message:string):Promise<boolean>
{
    const res = await command(`title @a ${type} ${message}`);
    return res.statusCode === 0;
}

const itemNameMap = new Map<Identifier, string>([
    [ID.concrete_powder, 'concretepowder'],
    [ID.double_stone_slab, 'stone_slab'],
    [ID.double_stone_slab2, 'stone_slab2'],
    [ID.double_stone_slab3, 'stone_slab3'],
    [ID.double_stone_slab4, 'stone_slab4'],
]);

/**
 * clear specfic items from user
 * return removed count
 * this function targeted to 1.12, it will returns wrong number in above 1.12
 * some furnaced items have 32767 data value, it will return very weird value.
 * You can fix it with -1 data number,   -1 data number will clear 32767 and 0 data value (not all data values)
 */
export async function clear(name:string, item:Identifier, data?:number, count?:number):Promise<number>
{
    const itemId = itemNameMap.get(item) || item.mini;
    let cmd = `clear "${name}" ${itemId}`;
    if (data !== undefined)
    {
        cmd += ' ';
        cmd += data;
        if (count !== undefined)
        {
            cmd += ' ';
            cmd += count;
        }
    }
    else
    {
        if (count !== undefined)
        {
            cmd += ' 0 ';
            cmd += count;
        }
    }
    const res = await command(cmd);
    const lang = await Lang.onLoad;
    
    count = count !== undefined ? count : 1;
    if (res.statusCode !== 0)
    {
        if (lang.commands.clear_failure.reset().exec(res.statusMessage))
        {
            return count >> 1;
        }
        return 0;
    }

    const regres = lang.commands.clear_success.reset().exec(res.statusMessage);
    if (!regres) return 0;
    const output = +regres[1];
    if (output >= count) return count;
    return (output + count) >> 1;
}

/**
 * clear specfic items from user with multiple datas
 * it repeats 'clear' command internally
 * return removed count
 * this function targeted to 1.12, it will returns wrong number in above 1.12
 * some furnaced items have 32767 data value, it will return very weird value.
 * You can fix it with -1 data number,   -1 data number will clear 32767 and 0 data value (not all data values)
 */
export async function clears(name:string, item:Identifier, datas:number[], count?:number):Promise<number>
{
    const itemId = itemNameMap.get(item) || item.mini;

    const pre_text = `clear "${name}" ${itemId} `;

    let removed = 0; 
    for (const data of datas)
    {
        let cmd = pre_text + data;
        if (count !== undefined)
        {
            const remained = count - removed;
            if (remained <= 0) return removed;
            cmd += ` ${remained}`;
        }
        const res = await command(cmd);
    
        const lang = await Lang.onLoad;
        if (res.statusCode !== 0)
        {
            if (lang.commands.clear_failure.reset().exec(res.statusMessage))
            {
                if (count === undefined) continue;
                removed += (count >> 1);
                continue;
            }
            continue;
        }
    
        const regres = lang.commands.clear_success.reset().exec(res.statusMessage);
        if (!regres) continue;

        const output = +regres[1];
        if (count === undefined) removed += output;
        else
        {
            if (output >= count) removed += count;
            else removed += ((output + count) >> 1);
        }
    }
    return removed;
}

/** give items to user */
export async function give(name:string, item:Identifier, count?:number, data?:number):Promise<void>
{
    const itemId = itemNameMap.get(item) || item.mini;
    let cmd = `give "${name}" ${itemId}`;
    if (count !== undefined)
    {
        cmd += ' ';
        cmd += count;
        if (data !== undefined)
        {
            cmd += ' ';
            cmd += data;
        }
    }
    else
    {
        if (data !== undefined)
        {
            cmd += ' 1 ';
            cmd += data;
        }
    }
    const res = await command(cmd);
    count = count !== undefined ? count : 1;
    if (res.statusCode !== 0)
    {
        console.error(`give ${name} ${item} ${count} ${data || 0} ${res.statusMessage}`);
    }
}

/** get day time */
export async function getDayTime():Promise<number>
{
    const res = await command('time query daytime');
    if (res.statusCode !== 0) throw commandError(res);
    const lang = await Lang.onLoad;
    lang.commands.time_query_daytime.reset();
    const regres = lang.commands.time_query_daytime.exec(res.statusMessage);
    if (!regres) throw Error('invalid daytime result');
    return +regres[0];
}

/**
 * get specific item count
 * this function targeted to 1.12, it will returns wrong number in above 1.12
 */
export async function getItemCount(name:string, item:Identifier, data:number):Promise<number>
{
    const res = await command(`clear "${name}" ${item} ${data} 0`);
    const lang = await Lang.onLoad;
    if (res.statusCode !== 0)
    {
        lang.commands.clear_failure_no_items.reset();
        if (lang.commands.clear_failure_no_items.exec(res.statusMessage) === null)
        {
            console.error(`clear "${name}" ${item} ${data} 0 - ${res.statusMessage}`);
        }
        return 0;
    }
    lang.commands.clear_testing.reset();
    const regres = lang.commands.clear_testing.exec(res.statusMessage);
    if (!regres)
    {
        console.error(`clear "${name}" ${item} ${data} 0 - ${res.statusMessage}`);
        return 0;
    }
    return +regres[1];
}

/** get specific item count with multiple datas */
export async function getItemCounts(name:string, item:Identifier, datas:number[]):Promise<number>
{
    
    const proms:Promise<CommandResult>[] = [];
    for (const data of datas)
    {
        proms.push(command(`clear "${name}" ${item} ${data} 0`));
    }
    const reses = await Promise.all(proms);
    
    let count = 0;
    const lang = await Lang.onLoad;
    for (const res of reses)
    {
        if (res.statusCode !== 0)
        {
            if (lang.commands.clear_failure_no_items.reset().exec(res.statusMessage) === null)
            {
                console.error(`clear "${name}" ${item} [${datas}] 0 - ${res.statusMessage}`);
            }
        }
        else
        {
            const regres = lang.commands.clear_testing.reset().exec(res.statusMessage);
            if (!regres)
            {
                console.error(`clear "${name}" ${item} [${datas}] 0 - ${res.statusMessage}`);
            }
            else
            {
                count += +regres[1];
            }
        }
    }
    return count;

}

/**
 * kill entities with mask
 * it's "kill @e[type=..]" wrapper
 */
export async function killEntities(mask?:{type?:Identifier}):Promise<string[]>
{
    let cmd = 'kill @e';
    if (mask)
    {
        cmd += '[';
        if (mask.type)
        {
            cmd += 'type=';
            cmd += mask.type.mini;
        }
        else
        {
            throw TypeError('Invalid arguments');
        }
        cmd += ']';
    }
    interface KillResult extends CommandResult
    {
        targetname:string[];
    }
    const res:KillResult = await command(cmd);
    if (res.statusCode !== 0) throw commandError(res);
    return res.targetname;
}

/** make particle */
export function particle(id:string, pos:VectorXYZ):Promise<CommandResult>
{
    return command(`particle ${id} ${pos.x} ${pos.y} ${pos.z}`);
}

/**
 * make particle with player
 * If player out, it will fail
 */
export function particleBy(player:string, id:string, pos:VectorXYZ):Promise<CommandResult>
{
    return command(`execute "${player}" ~ ~ ~ particle ${id} ${pos.x} ${pos.y} ${pos.z}`);
}

/** set spawnppoint of player */
export function spawnpoint(player:string, pos:VectorXYZ):Promise<CommandResult>
{
    return command(`spawnpoint "${player}" ${pos.x} ${pos.y} ${pos.z}`);
}
