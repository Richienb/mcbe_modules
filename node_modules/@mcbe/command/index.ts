
import Identifier from "@mcbe/identifier";
import ID from "@mcbe/identifier/id";

import { CommandResult, command } from "@mcbe/system_server";
import { lang } from "@mcbe/lang";
import ruacore from "@mcbe/ruacore_server";
import { SCORE_UNUSABLE_FILTER, SCORE_LIMIT } from "@mcbe/ruakr_const";

declare global
{
    interface Error
    {
        statusCode?:number;
    }
}

export function commandError(res:CommandResult):Error
{
    const err = Error(res.statusMessage);
    err.statusCode = res.statusCode;
    return err;
}

export interface Objective
{
    id:string;
    displayName:string;
    type:string;
}

export type Scores = {[key:string]:number};


export const scoreboard = {
    testInvalidCharacter(name:string):void
    {
        if (SCORE_UNUSABLE_FILTER.test(name))
        {
            const msg = 'Invalid character contains: '+name;
            console.error(msg);
            throw Error(msg);
        }
    },
    testInvalid(name:string):void
    {
        scoreboard.testInvalidCharacter(name);
        if (name.length > SCORE_LIMIT)
        {
            const msg = `${name} is too long(${name.length})`;
            console.error(msg);
            throw Error(msg);
        }
    },    
    players:{
        async list():Promise<string[]>
        {
            const res = await command('scoreboard players list');
            if (res.statusCode !== 0) throw commandError(res);
            const msg = res.statusMessage;
            const nextLine = msg.indexOf('\n');
            return msg.substr(nextLine+1).split(', ');
        },
        async listOf(player:string):Promise<Scores>
        {
            scoreboard.testInvalidCharacter(player);
            const res = await command(`scoreboard players list "${player}"`);
            if (res.statusCode !== 0) return {};
            const regexp = lang.commands.scoreboard_players_list_player_entry;
            const values:Scores = {};
            let arr:string[]|null;
            regexp.reset();
            while (arr = regexp.exec(res.statusMessage))
            {
                values[arr[1]] = (arr[0] as any) | 0;
            }
            return values;
        },
        async get(player:string, objective:string):Promise<number|undefined>
        {
            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players test "${player}" "${objective}" *`);
            if (res.statusCode !== 0) return undefined;
            const regres = lang.commands.scoreboard_players_test_success.reset().exec(res.statusMessage);
            if (!regres) throw commandError(res);
            return parseInt(regres[0]);
        },    
        async reset(player:string, objective?:string):Promise<void>
        {
            scoreboard.testInvalidCharacter(player);
            let cmd = `scoreboard players reset "${player}"`;
            if (objective)
            {
                scoreboard.testInvalid(objective);
                cmd += ' "';
                cmd += objective;
                cmd += '"';
            }
            const res = await command(cmd);
            if (res.statusCode !== 0)
            {
                console.error(`scoreboard players reset "${player}" ${res.statusMessage}`);
            }
        },
        async set(player:string, objective:string, count:number):Promise<void>
        {
            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players set "${player}" "${objective}" ${count}`);
            if (res.statusCode !== 0) throw commandError(res);
        },
        async add(player:string, objective:string, count:number):Promise<number>
        {
            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players add "${player}" "${objective}" ${count}`);
            if (res.statusCode !== 0) throw commandError(res);
            const regres = lang.commands.scoreboard_players_add_success.reset().exec(res.statusMessage);
            if (!regres) throw commandError(res);
            return parseInt(regres[3]);
        },
        async remove(player:string, objective:string, count:number):Promise<number>
        {
            scoreboard.testInvalidCharacter(player);
            scoreboard.testInvalid(objective);
            const res = await command(`scoreboard players remove "${player}" "${objective}" ${count}`);
            if (res.statusCode !== 0) throw commandError(res);
            const regres = lang.commands.scoreboard_players_remove_success.reset().exec(res.statusMessage);
            if (!regres) throw commandError(res);
            return parseInt(regres[3]);
        }
    },
    objectives: {

        async list():Promise<Objective[]>
        {
            const list = await command(`scoreboard objectives list`);
            const reg = lang.commands.scoreboard_objectives_list_entry;
            const message = list.statusMessage;
        
            reg.reset();
        
            const objectives:Objective[] = [];
            let res:string[]|null;
            while (res = reg.exec(message))
            {
                const id = res[0];
                const displayName = res[1];
                const type = res[2];
                objectives.push({id, displayName, type});
            }
            return objectives;
        },
        
        add(objective:string):Promise<CommandResult>
        {
            scoreboard.testInvalid(objective);
            return command(`scoreboard objectives add "${objective}" dummy`);
        },
        
        remove(objective:string):Promise<CommandResult>
        {
            scoreboard.testInvalid(objective);
            return command(`scoreboard objectives remove "${objective}"`);
        },
        
        setDisplay(type:'list'|'sidebar', objective?:string, order?:'ascending'|'descending'):Promise<CommandResult>
        {
            let cmd = `scoreboard objectives setdisplay ${type}`;
            if (objective)
            {
                scoreboard.testInvalid(objective);
                cmd += ' "';
                cmd += objective;
                cmd += '"';
                if (order)
                {
                    cmd += ' ';
                    cmd += 'order';
                }
            }
            return command(cmd);
        },
        
        async clear():Promise<void>
        {
            const list = await scoreboard.objectives.list();
            for (const obj of list)
            {
                scoreboard.objectives.remove(obj.id);
            }
        }
    }
};

export function say(message:string):void
{
    ruacore.broadcast.DisplayChat({message});
}

export interface ListResult extends CommandResult
{
    currentPlayer:number;
    maxPlayer:number;
    players:string;
}

export async function list():Promise<string[]>
{    
    const res:ListResult = await command<ListResult>('list');
    if (res.statusCode !== 0)
    {
        console.error('list '+res.statusMessage);
        return [];
    }
    return [res.players];
}

export async function kill(name:string):Promise<boolean>
{
    let cmd = `kill "${name}"`;
    const res = await command(cmd);
    return res.statusCode === 0;
}

export async function fill(from:VectorXYZ, to:VectorXYZ, type:Identifier, dataId?:number):Promise<boolean>
{
    let cmd = `fill ${from.x} ${from.y} ${from.z} ${to.x} ${to.y} ${to.z} ${type}`;
    if (dataId !== undefined)
    {
        cmd += ' ';
        cmd += dataId;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`fill ${from.x} ${from.y} ${from.z} ${type.mini} ${res.statusMessage}`);
        return false;
    }
    return true;
}

export async function fillx(from:VectorXYZ, to:VectorXYZ, type:Identifier, dataId?:number):Promise<void>
{
    const minx:number = Math.min(from.x, to.x);
    const miny:number = Math.min(from.y, to.y);
    const minz:number = Math.min(from.z, to.z);
    const maxx:number = Math.max(from.x, to.x) + 1;
    const maxy:number = Math.max(from.y, to.y) + 1;
    const maxz:number = Math.max(from.z, to.z) + 1;
    let extra = type+'';
    if (dataId !== undefined)
    {
        extra += ' ';
        extra += dataId;
    }

    const proms:Promise<CommandResult>[] = [];

    for (let z = minz; z < maxz; z+= 0x20)
    {
        const zto = Math.min(maxz - z, 0x20) + z - 1;
        for (let y = miny; y < maxy; y+= 0x20)
        {
            const yto = Math.min(maxy - y, 0x20) + y - 1;
            for (let x = minx; x < maxx; x+= 0x20)
            {
                const xto = Math.min(maxx - x, 0x20) + x - 1;
                proms.push(command(`fill ${x} ${y} ${z} ${xto} ${yto} ${zto} ${extra}`));
            }
        }
    }
    await Promise.all(proms);
}

export async function fillReplace(from:VectorXYZ, to:VectorXYZ, 
    type:Identifier, dataId:number, 
    typeFrom:Identifier, dataIdFrom:number):Promise<number>
{
    let cmd = `fill ${from.x} ${from.y} ${from.z} ${to.x} ${to.y} ${to.z} ${type} ${dataId} replace ${typeFrom} ${dataIdFrom}`;
    const res = await command(cmd);
    lang.commands.fill_success.reset();
    const regres = lang.commands.fill_success.exec(res.statusMessage);
    if (res.statusCode !== 0)
    {
        if (regres && regres[0] === '0') return 0;
        console.error(`fill replace(${type}, ${typeFrom}) ${res.statusMessage}`);
        return -1;
    }
    if (!regres) return 0;
    return +regres[0];
}


export async function testforblock(pos:VectorXYZ, type:Identifier):Promise<boolean>
{
    const res = await command(`testforblock ${pos.x} ${pos.y} ${pos.z} ${type}`);
    return res.statusCode === 0;
}


export async function testforblockBy(player:string, pos:VectorXYZ, type:Identifier):Promise<boolean>
{
    const res = await command(`execute "${player}" ~ ~ ~ testforblock ${pos.x} ${pos.y} ${pos.z} ${type}`);
    return res.statusCode === 0;
}


export async function setblock(to:VectorXYZ, type:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `setblock ${to.x} ${to.y} ${to.z} ${type}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0 ';
        cmd += option;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`setblock(${to.x},${to.y},${to.z},${type}) ${res.statusMessage}`);
        return false;
    }
    return true;
}


export async function setBlockBy(player:string, to:VectorXYZ, type:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `execute "${player}" ~ ~ ~ setblock ${to.x} ${to.y} ${to.z} ${type}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0';
        cmd += ' ';
        cmd += option;
    }
    const res = await command(cmd);
    if (res.statusCode !== 0)
    {
        console.error(`setBlockBy (${player},${to.x},${to.y},${to.z},${type}) ${res.statusMessage}`);
        return false;
    }
    return true;
}

export async function replaceBlockBy(user:string, pos:VectorXYZ, from:Identifier, to:Identifier):Promise<boolean>
{
    const postext = pos.x+' '+pos.y+' '+pos.z;
    const res = await command(`execute ${user} ~ ~ ~ detect ${postext} ${from} 0 setblock ${postext} ${to}`);
    return res.statusCode === 0;
}

export async function setblockWithoutError(pos:VectorXYZ, block:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `setblock ${pos.x} ${pos.y} ${pos.z} ${block}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0';
        cmd += ' ';
        cmd += option;
    }
    const res = await command(cmd);
    return res.statusCode === 0;
}

export async function setblockByWithoutError(player:string, to:VectorXYZ, type:Identifier, data?:number, option?:'destroy'|'keep'):Promise<boolean>
{
    let cmd = `execute "${player}" ~ ~ ~ setblock ${to.x} ${to.y} ${to.z} ${type}`;
    if (data)
    {
        cmd += ' ';
        cmd += data;
    }
    if (option)
    {
        if (!data) cmd += ' 0';
        cmd += ' ';
        cmd += option;
    }
    const res = await command(cmd);
    return res.statusCode === 0;
}

export async function tp(name:string, to:VectorXYZ):Promise<boolean>
{
    const res = await command(`tp "${name}" ${to.x} ${to.y} ${to.z}`);
    return res.statusCode === 0;
}

export async function titleTimes(name:string, fadeIn:number, stay:number, fadeOut:number):Promise<boolean>
{
    const res = await command(`title "${name}" times ${fadeIn} ${stay} ${fadeOut}`);
    return res.statusCode === 0;
}

export async function titleReset(name:string):Promise<boolean>
{
    const res = await command(`title "${name}" reset`);
    return res.statusCode === 0;
}

export async function title(name:string, type:'title'|'subtitle'|'actionbar', message:string):Promise<boolean>
{
    const res = await command(`title "${name}" ${type} ${message}`);
    return res.statusCode === 0;
}

export async function titleAll(type:'title'|'subtitle'|'actionbar', message:string):Promise<boolean>
{
    const res = await command(`title @a ${type} ${message}`);
    return res.statusCode === 0;
}

const itemNameMap = new Map<Identifier, string>([
    [ID.concrete_powder, 'concretepowder'],
    [ID.double_stone_slab, 'stone_slab'],
    [ID.double_stone_slab2, 'stone_slab2'],
    [ID.double_stone_slab3, 'stone_slab3'],
    [ID.double_stone_slab4, 'stone_slab4'],
]);

export async function clear(name:string, item:Identifier, data?:number, count?:number):Promise<number>
{
    const itemId = itemNameMap.get(item) || item.mini;
    let cmd = `clear "${name}" ${itemId}`;
    if (data !== undefined)
    {
        cmd += ' ';
        cmd += data;
        if (count !== undefined)
        {
            cmd += ' ';
            cmd += count;
        }
    }
    else
    {
        if (count !== undefined)
        {
            cmd += ' 0 ';
            cmd += count;
        }
    }
    const res = await command(cmd);
    
    count = count !== undefined ? count : 1;
    if (res.statusCode !== 0)
    {
        if (lang.commands.clear_failure.reset().exec(res.statusMessage))
        {
            return count >> 1;
        }
        return 0;
    }

    const regres = lang.commands.clear_success.reset().exec(res.statusMessage);
    if (!regres) return 0;
    const output = +regres[1];
    if (output >= count) return count;
    return (output + count) >> 1;
}

export async function clears(name:string, item:Identifier, datas:number[], count?:number):Promise<number>
{
    const itemId = itemNameMap.get(item) || item.mini;

    const pre_text = `clear "${name}" ${itemId} `;

    let removed = 0; 
    for (const data of datas)
    {
        let cmd = pre_text + data;
        if (count !== undefined)
        {
            const remained = count - removed;
            if (remained <= 0) return removed;
            cmd += ` ${remained}`;
        }
        const res = await command(cmd);
    
        if (res.statusCode !== 0)
        {
            if (lang.commands.clear_failure.reset().exec(res.statusMessage))
            {
                if (count === undefined) continue;
                removed += (count >> 1);
                continue;
            }
            continue;
        }
    
        const regres = lang.commands.clear_success.reset().exec(res.statusMessage);
        if (!regres) continue;

        const output = +regres[1];
        if (count === undefined) removed += output;
        else
        {
            if (output >= count) removed += count;
            else removed += ((output + count) >> 1);
        }
    }
    return removed;
}

export async function give(name:string, item:Identifier, count?:number, data?:number):Promise<void>
{
    const itemId = itemNameMap.get(item) || item.mini;
    let cmd = `give "${name}" ${itemId}`;
    if (count !== undefined)
    {
        cmd += ' ';
        cmd += count;
        if (data !== undefined)
        {
            cmd += ' ';
            cmd += data;
        }
    }
    else
    {
        if (data !== undefined)
        {
            cmd += ' 1 ';
            cmd += data;
        }
    }
    const res = await command(cmd);
    count = count !== undefined ? count : 1;
    if (res.statusCode !== 0)
    {
        console.error(`give ${name} ${item} ${count} ${data || 0} ${res.statusMessage}`);
    }
}

export async function getDayTime():Promise<number>
{
    const res = await command('time query daytime');
    if (res.statusCode !== 0) throw commandError(res);
    lang.commands.time_query_daytime.reset();
    const regres = lang.commands.time_query_daytime.exec(res.statusMessage);
    if (!regres) throw Error('invalid daytime result');
    return +regres[0];
}

export async function getItemCount(name:string, item:Identifier, data:number):Promise<number>
{
    const res = await command(`clear "${name}" ${item} ${data} 0`);
    if (res.statusCode !== 0)
    {
        lang.commands.clear_failure_no_items.reset();
        if (lang.commands.clear_failure_no_items.exec(res.statusMessage) === null)
        {
            console.error(`clear "${name}" ${item} ${data} 0 - ${res.statusMessage}`);
        }
        return 0;
    }
    lang.commands.clear_testing.reset();
    const regres = lang.commands.clear_testing.exec(res.statusMessage);
    if (!regres)
    {
        console.error(`clear "${name}" ${item} ${data} 0 - ${res.statusMessage}`);
        return 0;
    }
    return +regres[1];
}

export async function getItemCounts(name:string, item:Identifier, datas:number[]):Promise<number>
{
    
    const proms:Promise<CommandResult>[] = [];
    for (const data of datas)
    {
        proms.push(command(`clear "${name}" ${item} ${data} 0`));
    }
    const reses = await Promise.all(proms);
    
    let count = 0;
    for (const res of reses)
    {
        if (res.statusCode !== 0)
        {
            if (lang.commands.clear_failure_no_items.reset().exec(res.statusMessage) === null)
            {
                console.error(`clear "${name}" ${item} [${datas}] 0 - ${res.statusMessage}`);
            }
        }
        else
        {
            const regres = lang.commands.clear_testing.reset().exec(res.statusMessage);
            if (!regres)
            {
                console.error(`clear "${name}" ${item} [${datas}] 0 - ${res.statusMessage}`);
            }
            else
            {
                count += +regres[1];
            }
        }
    }
    return count;

}

export async function killEntities(mask?:{type?:Identifier}):Promise<string[]>
{
    let cmd = 'kill @e';
    if (mask)
    {
        cmd += '[';
        if (mask.type)
        {
            cmd += 'type=';
            cmd += mask.type.mini;
        }
        else
        {
            throw TypeError('Invalid arguments');
        }
        cmd += ']';
    }
    interface KillResult extends CommandResult
    {
        targetname:string[];
    }
    const res:KillResult = await command(cmd);
    if (res.statusCode !== 0) throw commandError(res);
    return res.targetname;
}

export function particle(id:string, pos:VectorXYZ):Promise<CommandResult>
{
    return command(`particle ${id} ${pos.x} ${pos.y} ${pos.z}`);
}

export function particleBy(user:string, id:string, pos:VectorXYZ):Promise<CommandResult>
{
    return command(`execute ${user} ~ ~ ~ particle ${id} ${pos.x} ${pos.y} ${pos.z}`);
}
