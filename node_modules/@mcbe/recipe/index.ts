
import Identifier from "@mcbe/identifier";

export enum DeleteTarget
{
    None,
    This,
    Other,
}

export class Recipe
{
    constructor(
        public readonly tools:Identifier[],
        public readonly inputs:[Identifier, number][], 
        public readonly count:number = 1)
    {
    }

    private _compareTool(other:Recipe):DeleteTarget
    {
        _next:{
            const a_set = new Set(this.tools);
            for (const b of other.tools)
            {
                if (!a_set.has(b)) break _next;
            }
            return DeleteTarget.Other;
        }
        const b_set = new Set(this.tools);
        for (const a of this.tools)
        {
            if (!b_set.has(a)) return DeleteTarget.None;
        }
        return DeleteTarget.This;
    }
    
    subsetCompare(other:Recipe):DeleteTarget
    {
        const b_map = new Map(other.inputs);
        const tool = this._compareTool(other);
        if (tool === DeleteTarget.None) return DeleteTarget.None;
        _next: {
            if (tool === DeleteTarget.This) break _next;
            if (other.count > this.count) break _next;
            for (const [a_id, a_count] of this.inputs)
            {
                const b_count = b_map.get(a_id);
                if (b_count === undefined) break _next;
                if (a_count > b_count) break _next;
            }
            return DeleteTarget.Other;
        }
        if (this.count > other.count) return DeleteTarget.None;
        const a_map = new Map(this.inputs);
        for (const [b_id, b_count] of other.inputs)
        {
            const a_count = a_map.get(b_id);
            if (a_count === undefined) return DeleteTarget.None;
            if (b_count > a_count) return DeleteTarget.None;
        }
        return DeleteTarget.This;
    }

    complexCompare(other:Recipe):number
    {
        const a = this.inputs.map(v=>v[1]).reduce((a,b)=>a+b) / this.count;
        const b = other.inputs.map(v=>v[1]).reduce((a,b)=>a+b) / this.count;
        return a - b;
    }

    inputHas(item:Identifier, count:number):boolean
    {
        for (const [i_id, i_count] of this.inputs)
        {
            if (i_id === item && i_count >= count) return true;
        }
        
        return false;
    }

    

    toSource():string
    {
        let out = 'new Recipe([';
        if (this.tools.length !== 0)
        {
            out += 'ID.';
            out += this.tools.join(', ID.');
        }
        out += '],[';
        for (const [id, count] of this.inputs)
        {
            out += '[ID.';
            out += id;
            out += ', ';
            out += count;
            out += '],';
        }
        out += '],';
        out += this.count;
        out += ')';
        return out;
    }
}
