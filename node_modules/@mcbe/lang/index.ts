
import escapeStringRegexp = require('escape-string-regexp');
import { SCORE_UNUSABLE } from '@mcbe/ruakr_const';
import { command } from '@mcbe/system_server';
import { entiresOf } from '@mcbe/ruakr_util';
import Identifier from '@mcbe/identifier';

import { lang_data } from './lang_data';

const MATCH = /%[sd]|%([0-9])(?:\\\$([sd]))?/g;

const UNUSABLE_FILTER = '([^'+SCORE_UNUSABLE+']+)';


class Matcher
{
    private readonly indexes:(number|undefined)[];
    private readonly regexp:RegExp;

    constructor(msg:string)
    {
        const indexes:(number|undefined)[] = [];
        this.indexes = indexes;
        let idx = 1;
        let regexp_idx = 0;
        msg = ('^'+escapeStringRegexp(msg)+'$').replace(MATCH, (matched:string, pos:string, type:string)=>{
            if (!pos)
            {
                while (indexes[idx] !== undefined)
                {
                    idx ++;
                }
                indexes[idx++] = regexp_idx++;
                type = matched[1];
            }
            else
            {
                indexes[+pos] = regexp_idx++;
                if (type === undefined)
                {
                    type = 's';
                }
            }
            switch (type)
            {
            case 's': return UNUSABLE_FILTER;
            case 'd': return '(-?[0-9]+)';
            default: throw Error('unknown matcher %'+type);
            }
        });
        this.regexp = new RegExp(msg, 'gm');
    }

    reset():this
    {
        this.regexp.lastIndex = 0;
        return this;
    }

    exec(msg:string):string[]|null
    {
        const res:string[] = [];
        const matched = this.regexp.exec(msg);
        if (!matched) return null;
        for (let i=0;i<matched.length;i++)
        {
            const idx = this.indexes[i];
            if (idx === undefined) continue;
            res[idx] = matched[i];
        }
        return res;
    }
}

type LangId = keyof typeof lang_data;
type CommandIds = keyof typeof lang_data['en_US']['commands'];

class Lang
{
    public id:LangId|null = null;
    public commands:{readonly [key in CommandIds]: Matcher};
    public readonly onLoad = (async()=>{
        const res = await command('scoreboard objectives add "" dummy');
        const needName = res.statusMessage;
        
        for (const [langId, lang_data_in] of entiresOf(lang_data))
        {
            const commands = lang_data_in.commands;
            if (commands.scoreboard_objectives_add_needName === needName)
            {
                this.id = langId;
                const commandsMatchers:{[key in CommandIds]:Matcher} = {} as any;
                for (const [key, value] of entiresOf(commands))
                {
                    commandsMatchers[key] = new Matcher(value);
                }
                Object.freeze(commandsMatchers);
                this.commands = commandsMatchers;
                break;
            }
        }
        
        Object.freeze(this);
        if (this.id === null) console.error('Language: Unsupported');
        else console.log('Language: ' + this.id);
        return this;
    })().catch(err=>{
        console.error(err);
        return this;
    });
}

class ItemLang
{
    constructor(public items:{readonly [key:string]:readonly (string|null)[]})
    {
    }

    get(item:Identifier, id?:number):string
    {
        const name = this.items[item.mini];
        if (name)
        {
            if (id !== undefined)
            {
                const out = name[id+1];
                if (out) return out;
            }
            const out = name[0];
            if (out) return out;
        }
        console.error('Name not found: '+item.mini);
        return item.mini;
    }
}

export const lang:Lang = new Lang;
export let itemLang:ItemLang = new ItemLang(lang_data.en_US.item);

export function setItemLang(lang:keyof typeof lang_data):void
{
    const selected = lang_data[lang].item;
    if (!selected) throw Error('Not supported language: '+lang);
    itemLang.items = selected;
}
