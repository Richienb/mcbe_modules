
import escapeStringRegexp = require('escape-string-regexp');
import { SCOREBOARD_UNUSABLE_CHARACTER } from '@mcbe/ruakr_const';
import { command } from '@mcbe/system_server';
import { entiresOf } from '@mcbe/ruakr_util';
import Identifier from '@mcbe/identifier';

import { lang_data } from './lang_data';

const MATCH = /%[sd]|%([0-9])(?:\\\$([sd]))?/g;

const UNUSABLE_FILTER = '([^'+SCOREBOARD_UNUSABLE_CHARACTER+']+)';


class Matcher
{
    private readonly indexes:(number|undefined)[];
    private readonly regexp:RegExp;

    constructor(msg:string)
    {
        const indexes:(number|undefined)[] = [];
        this.indexes = indexes;
        let idx = 1;
        let regexp_idx = 0;
        msg = ('^'+escapeStringRegexp(msg)+'$').replace(MATCH, (matched:string, pos:string, type:string)=>{
            if (!pos)
            {
                while (indexes[idx] !== undefined)
                {
                    idx ++;
                }
                indexes[idx++] = regexp_idx++;
                type = matched[1];
            }
            else
            {
                indexes[+pos] = regexp_idx++;
                if (type === undefined)
                {
                    type = 's';
                }
            }
            switch (type)
            {
            case 's': return UNUSABLE_FILTER;
            case 'd': return '(-?[0-9]+)';
            default: throw Error('unknown matcher %'+type);
            }
        });
        this.regexp = new RegExp(msg, 'gm');
    }

    reset():this
    {
        this.regexp.lastIndex = 0;
        return this;
    }

    exec(msg:string):string[]|null
    {
        const res:string[] = [];
        const matched = this.regexp.exec(msg);
        if (!matched) return null;
        for (let i=0;i<matched.length;i++)
        {
            const idx = this.indexes[i];
            if (idx === undefined) continue;
            res[idx] = matched[i];
        }
        return res;
    }
}

type LangId = keyof typeof lang_data;
type CommandIds = keyof typeof lang_data['en_US']['commands'];

export class Lang
{
    public id:LangId|null = null;
    public commands:{readonly [key in CommandIds]: Matcher};
    
    static set(langId:LangId):Lang
    {
        lang.id = langId;
        const commands = lang_data[langId].commands
        const commandsMatchers:{[key in CommandIds]:Matcher} = {} as any;
        for (const [key, value] of entiresOf(commands))
        {
            commandsMatchers[key] = new Matcher(value);
        }
        Object.freeze(commandsMatchers);
        lang.commands = commandsMatchers;
        return lang;
    }

    public static readonly onLoad = (async()=>{
        const res = await command('scoreboard objectives add "" dummy');
        if (lang.commands) return lang;
        const needName = res.statusMessage;
        
        for (const [langId, lang_data_in] of entiresOf(lang_data))
        {
            if (lang_data_in.commands.scoreboard_objectives_add_needName === needName)
            {
                Lang.set(langId);
                break;
            }
        }
        
        if (lang.id === null) console.error('Language: Unsupported');
        else console.log('Language: ' + lang.id);
        return lang;
    })().catch(err=>{
        console.error(err);
        return lang;
    });
}

class ItemLang
{
    constructor(public items:{readonly [key:string]:readonly (string|null)[]})
    {
    }

    get(item:Identifier, id?:number):string
    {
        const name = this.items[item.mini];
        if (name)
        {
            if (id !== undefined)
            {
                const out = name[id+1];
                if (out) return out;
            }
            const out = name[0];
            if (out) return out;
        }
        console.error('Name not found: '+item.mini);
        return item.mini;
    }
    
    set(lang:LangId):void
    {
        const selected = lang_data[lang].item;
        itemLang.items = selected;
    }
}

const lang:Lang = new Lang;
export let itemLang:ItemLang = new ItemLang(lang_data.en_US.item);
