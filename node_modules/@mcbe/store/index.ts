
import { timerIsNeeded } from "krchecktimer";
import { Scoreboard } from "@mcbe/scoreboard";
import { scoreboard } from "@mcbe/command";
import ruacore from "@mcbe/ruacore_server";

timerIsNeeded("store");

export class Storage
{
    private readonly board:Scoreboard;
    private readonly prev = new Map<string, number>();
    private readonly now = new Map<string, number>();
    public notExists:boolean = false;
    public deleted:boolean = false;
    private savingWait:NodeJS.Timeout|null = null;
    
    constructor(
        private readonly store:Store, 
        public readonly name:string)
    {
        this.board = new Scoreboard(store.prefix + '_' + name);
    }

    rename(newname:string):Storage|null
    {
        if (this.store.peek(newname)) return null;
        const s = this.store.get(newname);
        for (const [key, value] of this.entires())
        {
            s.set(key, value);
        }
        this.dispose();
        return s;
    }

    size():number
    {
        return this.now.size;
    }

    clear():void
    {
        this.now.clear();
    }

    dispose():void
    {
        this.now.clear();
        this.prev.clear();
        this.deleted = true;
        this.save();
    }

    get(key:string):number|undefined
    {
        return this.now.get(key);
    }

    setDefault(key:string, value:number):void
    {
        if (this.get(key) === undefined)
        {
            this.set(key, value);
        }
    }
    
    set(key:string, value:number):void
    {
        this.now.set(key, value);
        this.save();
    }
    
    add(key:string, value:number):number
    {
        const old = this.now.get(key);
        const v = old !== undefined ? old + value : value;
        this.now.set(key, v);
        this.save();
        return v;
    }
    
    remove(key:string, value:number):number
    {
        const old = this.now.get(key);
        const v = old !== undefined ? old - value : -value;
        this.now.set(key, v);
        this.save();
        return v;
    }

    delete(key:string):void
    {
        this.now.delete(key);
        this.save();
    }

    setWithoutSave(key:string, value?:number):void
    {
        if (value === undefined)
        {
            this.now.delete(key);
            this.prev.delete(key);
        }
        else
        {
            this.now.set(key, value);
            this.prev.set(key, value);
        }
    }

    async update(key:string):Promise<void>
    {
        const value = await this.board.get(key);
        this.setWithoutSave(key, value);
    }

    async updateAll():Promise<void>
    {
        const all = await this.board.list();
        this.now.clear();
        this.prev.clear();
        for (const p in all)
        {
            const v = all[p];
            this.now.set(p, v);
            this.prev.set(p, v);
        }
    }

    keys():IterableIterator<string>
    {
        return this.now.keys();
    }

    entires():IterableIterator<[string, number]>
    {
        return this.now.entries();
    }

    private _save():void
    {
        if (this.deleted)
        {
            if (!this.notExists)
            {
                this.notExists = true;
                this.board.reset();
                this.store._delete(this.name);
            }
            return;
        }
        if (this.notExists)
        {
            this.notExists = false;
        }

        for (const p of this.prev.keys())
        {
            if (!this.now.has(p))
            {
                this.prev.delete(p);
                this.board.reset(p);
            }
        }

        for (const [p, v] of this.now)
        {
            if (v === this.prev.get(p)) continue;
            this.prev.set(p, v);
            this.board.set(p, v);
        }
    }

    save():void
    {
        if (this.savingWait) clearTimeout(this.savingWait);
        this.savingWait = setTimeout(()=>{
            this.savingWait = null;
            this._save();
        }, 1000);
    }

    saveNow():void
    {
        if (this.savingWait) clearTimeout(this.savingWait);
        this.savingWait = null;
        this._save();
    }

    cleanObjectiveWithoutSave(objective:string):void
    {
        this.now.delete(objective);
        this.prev.delete(objective);
    }
}

class InitScoreboard
{
    constructor(
        public readonly scoreboards:string[])
    {
    }

    use(cb:(name:string)=>boolean):void
    {
        for (let i=0;i<this.scoreboards.length;)
        {
            if (cb(this.scoreboards[i]))
            {
                const last = this.scoreboards.pop();
                if (this.scoreboards.length !== i)
                {
                    this.scoreboards[i] = last!;
                }
            }
            else
            {
                i++;
            }
        }
    }
}

let storeLoaded = false;

export class Store
{
    private static readonly all = new Map<string, Store>();
    private readonly data = new Map<string, Storage>();

    constructor(public readonly prefix:string)
    {
        console.assert(prefix.indexOf('_') === -1, 'prefix is not allowed underscope');
        console.assert(!Store.all.has(prefix), 'already using prefix: ' + prefix);
        Store.all.set(prefix, this);
    }

    * entires():IterableIterator<[string, Storage]>
    {
        if (!storeLoaded) throw Error('Loading');
        for (const entry of this.data.entries())
        {
            if (entry[1].deleted) continue;
            yield entry;
        }
    }

    * values():IterableIterator<Storage>
    {
        if (!storeLoaded) throw Error('Loading');
        for (const entry of this.data.values())
        {
            if (entry.deleted) continue;
            yield entry;
        }
    }

    cleanObjectiveWithoutSave(objective:string):void
    {
        for (const user of this.values())
        {
            user.cleanObjectiveWithoutSave(objective);
        }
    }
    
    dispose(name:string):void
    {
        if (!storeLoaded) throw Error('Loading');
        const obj = this.data.get(name);
        if (!obj) return;
        obj.dispose();
    }

    peek(name:string):Storage|null
    {
        if (!storeLoaded) throw Error('Loading');
        const obj = this.data.get(name);
        if (obj && !obj.deleted) return obj;
        return null;
    }

    get(name:string):Storage
    {
        if (!storeLoaded) throw Error('Loading');
        const obj = this.data.get(name);
        if (obj)
        {
            obj.deleted = false;
            obj.save();
            return obj;
        }
        const s = new Storage(this, name);
        s.notExists = true;
        this.data.set(name, s);
        s.save();
        return s;
    }

    save():void
    {
        if (!storeLoaded) throw Error('Loading');
        for (const storage of this.data.values())
        {
            storage.save();
        }
    }

    saveNow():void
    {
        if (!storeLoaded) throw Error('Loading');
        for (const storage of this.data.values())
        {
            storage.saveNow();
        }
    }

    _delete(name:string):void
    {
        this.data.delete(name);
    }
    
    async load(name:string):Promise<Storage>
    {
        const s = new Storage(this, name);
        this.data.set(name, s);

        await s.updateAll();
        return s;
    }

    static saveNowAll():void
    {
        if (!storeLoaded) throw Error('Loading');
        for (const store of Store.all.values())
        {
            store.saveNow();
        }
    }

    static async updateAll():Promise<InitScoreboard>
    {
        const scoreboards = await scoreboard.players.list();
        const loadings:Promise<unknown>[] = [];
        const data = new InitScoreboard(scoreboards);
        data.use(sbname=>{
            const prefix_idx = sbname.indexOf('_');
            if (prefix_idx === -1) return false;

            const prefix = sbname.substr(0, prefix_idx);
            const name = sbname.substr(prefix_idx+1);
            const store = Store.all.get(prefix);
            if (store)
            {
                if (storeLoaded)
                {
                    const s = store.peek(name);
                    if (s)
                    {
                        loadings.push(s.updateAll());
                        return true;
                    }
                }
                loadings.push(store.load(name));
                return true;
            }
            return false;
        });
        
        await Promise.all(loadings);
        return data;
    }

    public static readonly onLoad = (async()=>{
        const data = await Store.updateAll();
        storeLoaded = true;
        return data;
    })();
}

ruacore.shutdown.on(Store.saveNowAll);
