
import { Vector3 } from "krgeometry";
import ID from "@mcbe/identifier/id";
import Identifier from "@mcbe/identifier";
import { ItemList, ItemStack } from "@mcbe/item";
import { Store, Storage } from "@mcbe/store";
import { execute } from "@mcbe/command";
import { timepack } from "@mcbe/ruakr_util";

import { UserLike } from "@bdsx/block";

const VAR_CONTAINER_TYPE = '#type';
const VAR_CONTAINER_LAST = '#last';

function makeCoordId(pos:Vector3):string
{
    return pos.x+'_'+pos.y+'_'+pos.z;
}

function makeEnderId(opener:string):string
{
    return 'e_'+opener;
}

function getContainerTypeFrom(s:Storage):number
{
    const type = s.get(VAR_CONTAINER_TYPE);
    if (type !== undefined) return type;
    console.error(`*${s.name}: no flags`);
    s.set(VAR_CONTAINER_TYPE, 0);
    return 0;
}

function peekArround(flags:number, pos:Vector3):Container|null
{
    const id = makeCoordId(pos);
    const c = peekById(id);
    if (c) return c;
    switch (flags & Container.CHEST_MASK)
    {
    case Container.CHEST_YES:
        return peekAroundChestByPosition(id, pos);
    default:
        return null;
    }
}

const store = new Store('c');

const containers = new Map<string, Container>();

export class Container
{
    static readonly INVALID = -1;
    
    static readonly CHEST_UNKNOWN = 0 << 2;
    static readonly CHEST_NO = 1 << 2;
    static readonly CHEST_YES = 2 << 2;
    static readonly CHEST_ENDER = 3 << 2;
    static readonly CHEST_MASK = 3 << 2;
    
    static readonly ALL_MASK = Container.CHEST_MASK;
    static readonly store = store;
    static readonly FLAGS_MAP = new Map<Identifier, number>([
        [ID.lit_furnace, Container.CHEST_NO],
        [ID.lit_blast_furnace, Container.CHEST_NO],
        [ID.lit_smoker, Container.CHEST_NO],
        [ID.furnace, Container.CHEST_NO],
        [ID.blast_furnace, Container.CHEST_NO],
        [ID.smoker, Container.CHEST_NO],
        [ID.brewing_stand, Container.CHEST_NO],
        [ID.hopper, Container.CHEST_NO],
        [ID.dispenser, Container.CHEST_NO],
        [ID.dropper, Container.CHEST_NO],
        [ID.barrel, Container.CHEST_NO],
        [ID.chest, Container.CHEST_YES],
        [ID.trapped_chest, Container.CHEST_YES],        
        [ID.ender_chest, Container.CHEST_ENDER],
    ]);
    
    private readonly ids:string[];


    constructor(
        id:string, 
        public readonly storage:Storage)
    {
        this.ids = [id];
        containers.set(id, this);

        getContainerTypeFrom(this.storage);
        this.updateUse();
    }

    addId(id:string):void
    {
        this.ids.push(id);
        containers.set(id, this);
    }

    getId():string[]
    {
        return this.ids;
    }

    destroy():void
    {
        for (const id of this.ids)
        {
            containers.delete(id);
        }
        for (let i=1;i<this.ids.length;i++)
        {
            store.dispose(this.ids[i]);
        }
        this.storage.dispose();
    }

    getFlags():number
    {
        return this.storage.get(VAR_CONTAINER_TYPE)!;
    }

    getLastUse():number
    {
        return this.storage.get(VAR_CONTAINER_LAST)!;
    }

    updateUse():void
    {
        this.storage.set(VAR_CONTAINER_LAST, timepack.now());
    }

    setFlags(flags:number):void
    {
        this.storage.set(VAR_CONTAINER_TYPE, flags);
    }

    getChestType():number
    {
        return this.getFlags() & Container.CHEST_MASK;
    }

    put(item:Identifier, count:number):void
    {
        this.storage.add(item.short, count);
        this.updateUse();
    }

    get(item:Identifier, count:number):number
    {
        const newcount = this.storage.remove(item.short, count);
        if (newcount <= 0)
        {
            this.storage.delete(item.short);
        }
        return newcount;
    }

    getAll(dest:ItemList):void
    {
        for (const [key, value] of this.storage.entires())
        {
            if (key.startsWith('#')) continue;
            dest.add(Identifier.getFromShort(key), value);
        }
    }

    updateAll(src:ItemList):void
    {
        for (const remained of this.storage.keys())
        {
            if (remained.startsWith('#')) continue;
            if (src.get(Identifier.getFromShort(remained))) continue;
            this.storage.delete(remained);
        }
        for (const item of src.values())
        {
            const old = this.storage.get(item.id.short);
            if (old !== item.count)
            {
                this.storage.set(item.id.short, Math.max(item.count, 0));
            }
        }
        this.updateUse();
    }

    *list():IterableIterator<ItemStack>
    {
        for (const [short, count] of this.storage.entires())
        {
            if (short === VAR_CONTAINER_TYPE) continue;
            if (short === VAR_CONTAINER_LAST) continue;
            const id = Identifier.getFromShort(short);
            yield {id, count};
        }
    }

    getInventoryText():string
    {
        let out = `--- ${this.ids.join(',')} (0x${this.getFlags().toString(16)}) ---`;
        let empty = true;
        for (const item of this.list())
        {
            out += `\n${item.id}: ${item.count}`;
            empty = false;
        }
        if (empty)
        {
            out += '\nempty';
        }
        return out;
    }

    static isChest(id:Identifier):boolean
    {
        return id === ID.chest || id === ID.trapped_chest;
    }

    static getFlags(id:Identifier):number
    {
        return Container.FLAGS_MAP.get(id) ?? Container.INVALID;
    }
    
    static onDestroy(user:UserLike, flags:number, position:Vector3):void
    {
        if (flags === Container.CHEST_YES)
        {
            const area = user.getTickingArea();
            const destroyChest = (pos:Vector3)=>{
                const block = area.getBlock(pos);
                if (!block) return;
                if (Container.isChest(block.id)) block.destroy();
            };
            destroyChest(position.sub(Vector3.X));
            destroyChest(position.add(Vector3.X));
            destroyChest(position.sub(Vector3.Z));
            destroyChest(position.add(Vector3.Z));
        }
        
        const chest = peekArround(flags, position);
        if (!chest) return;
        
        chest.destroy();
    }

    static destroy(user:UserLike, flags:number, position:Vector3):void
    {
        execute(user.name).setblock(position, ID.air, 0, 'destroy');
        Container.onDestroy(user, flags, position);
    }

    static getEnder(opener:string):Container
    {
        const id = makeEnderId(opener);
        let c = peekById(id);
        if (c) return c;

        const s = store.create(id);
        s.set(VAR_CONTAINER_TYPE, Container.CHEST_ENDER);
        return new Container(id, s);
    }
    
    static peek(opener:string, flags:number, pos:Vector3):Container|null
    {
        switch (flags)
        {
        case Container.CHEST_ENDER:
            return Container.getEnder(opener);
        case Container.CHEST_NO:
            return peekById(makeCoordId(pos));
        case Container.CHEST_YES:
            return peekArround(flags, pos);
        default:
            throw Error('Invalid contanier flags: 0x'+flags.toString(16));
        }
    }

    static create(flags:number, pos:Vector3):Container|null
    {
        const id = makeCoordId(pos);
        let c = peekById(id);
        if (c) return c;

        switch (flags)
        {
        case Container.CHEST_NO: break;
        case Container.CHEST_YES:
            c = peekAroundChestByPosition(id, pos);
            if (c) return c;
            break;
        default:
            throw Error(`Container.create 0x${flags.toString(16)}`);
        }

        const s = store.create(id);
        s.set(VAR_CONTAINER_TYPE, flags);
        return new Container(id, s);
    }

    static cleanEnder(opener:string):void
    {
        const id = makeEnderId(opener);
        store.dispose(id);
    }

    static search(item:Identifier):void
    {
        for (const s of store.values())
        {
            const count = s.get(item.minified);
            if (count) console.log(s.name+': '+count);
        }
    }

    toString():string
    {
        return 'container('+this.ids.join(',')+')';
    }
}

function peekById(id:string):Container|null
{
    const c = containers.get(id);
    if (c) return c;
    const s = store.get(id);
    if (s) return new Container(id, s);
    return null;
}

function peekAroundChestByPosition(id:string, pos:Vector3):Container|null
{
    function peekChest(pos:Vector3):Container|null
    {
        const id = makeCoordId(pos);
        const c = containers.get(id);
        if (c)
        {
            if (c.getChestType() === Container.CHEST_YES) return c;
            else return null;
        }
        const s = store.get(id);
        if (s)
        {
            const flags = s.get(VAR_CONTAINER_TYPE);
            if (flags === undefined) return null;
            if ((flags & Container.CHEST_MASK) === Container.CHEST_YES)
            {
                return new Container(id, s);
            }
        }
        return null;
    }
    const chest = peekChest(pos.add(Vector3.X)) || 
                peekChest(pos.add(Vector3.Z)) || 
                peekChest(pos.sub(Vector3.X)) || 
                peekChest(pos.sub(Vector3.Z));
    if (chest)
    {
        chest.addId(id);
        return chest;
    }
    return null;
}

Store.onLoad.then(data=>{
    for (const s of store.values())
    {
        if (!s.get(VAR_CONTAINER_TYPE))
        {
            s.dispose();
            continue;
        }

        s.reminify();
    }
});
