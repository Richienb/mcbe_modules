
import Event from "krevent";

declare global
{
    const console:{
        log(msg:any, ...params:any[]):void;
        error(msg:any, ...params:any[]):void;
        warn(msg:any, ...params:any[]):void;
        assert(value:any, ...params:any[]):void;
    };
}

export enum LogLevel
{
    Verbose,
    Message,
    Warning,
    Error,
}

const logarray:string[] = [];

class ListenerWaiter
{
    private readonly waiting:string[] = [];
    private finished = false;

    constructor()
    {
    }

    finish():void
    {
        if (this.finished) return;
        this.finished = true;

        Promise.resolve().then(()=>{
            if (listenerWaiter === this)
            {
                listenerWaiter = null;
            }
            for (const log of this.waiting)
            {
                logListener.fire(log.charCodeAt(0), log.substr(1));
            }
        });
    }

    keep(level:LogLevel, message:string):void
    {
        this.waiting.push(String.fromCharCode(level) + message);
        if (this.waiting.length > 100)
        {
            this.waiting.shift();
        }
    }
}
var listenerWaiter:ListenerWaiter|null = new ListenerWaiter;

class LogEvent extends Event<(level:LogLevel, message:string)=>void>
{
    on(listener:(level:LogLevel, message:string)=>void):void
    {
        super.on(listener);
        if (listenerWaiter) listenerWaiter.finish();
    }

    remove(listener:(level:LogLevel, message:string)=>void):boolean
    {
        const removed = super.remove(listener);
        if (!removed) return false;
        if (this.isEmpty())
        {
            listenerWaiter = new ListenerWaiter;
        }
        return true;
    }
}

export const logListener = new LogEvent();
const REPORT_PAGE = 5;
let keepLevel = LogLevel.Message;
let printLevel = LogLevel.Message;

function print(level:LogLevel, message:string):void
{
    if (listenerWaiter) listenerWaiter.keep(level, message);
    else logListener.fire(level, message);
}

export function log(level:LogLevel, message:string):void
{
    if (level >= keepLevel)
    {
        logarray.push(message);
    }
    if (level >= printLevel)
    {
        print(level, message);
    }
}

export function logVerbose(message:string):void
{
    log(LogLevel.Verbose, message);
}

export function logMessage(message:string):void
{
    log(LogLevel.Message, message);
}

export function logWarning(message:string):void
{
    log(LogLevel.Warning, message);
}

export function logError(message:string):void
{
    log(LogLevel.Error, message);
}

export function setLogLevel(_printLevel:LogLevel, _keepLevel?:LogLevel):void
{
    printLevel = _printLevel;
    if (_keepLevel !== undefined) keepLevel = _keepLevel;
    else keepLevel = _printLevel;
}

let reportPage = -1;

export const logPage = {
    *currentPage():IterableIterator<[LogLevel, string]>
    {
        if (reportPage < 0 || reportPage >= logarray.length)
        {
            return [].values();
        }
        let i = reportPage * REPORT_PAGE;
        const end = Math.min(i + REPORT_PAGE, logarray.length);
        while (i < end)
        {
            const line = logarray[i];
            yield [line.charCodeAt(0), line.substr(1)];
            i++;
        }
    },
    allPages():string[]
    {
        return logarray;
    },   
    get page():number
    {
        return reportPage + 1;
    },
    get pageCount():number
    {
        return Math.ceil(logarray.length/REPORT_PAGE);
    },        
    previous():boolean
    {
        if (reportPage < 0) return false;
        reportPage --;
        return true;
    },
    next():boolean
    {
        const maxPage = Math.floor(logarray.length/REPORT_PAGE);
        reportPage = Math.min(reportPage+1, maxPage+1);
        if (reportPage > maxPage) return false;
        reportPage ++;
        return true;
    },
    clear():void
    {
        reportPage = 0;
        logarray.length = 0;
    }
};

function getStack(err:Error):string
{
    return err.stack!.replace(/\([a-f0-9\-]+_[0-9]+\.[0-9]+\.[0-9]+_scripts\/([^)]+)_[a-f0-9]+:([0-9]+:[0-9]+)\)/gm, (a, $1, $2)=>{
        return '('+$1+':'+$2+')';
    });
}

function joinConsoleMessage(message:unknown, params:string[]):string
{
    if (message instanceof Error)
    {
        message = getStack(message);
    }
    if (params.length >= 0)
    {
        return message+' '+params.join(' ');
    }
    else
    {
        return message+'';
    }
}

export function install():void
{
    new Function('console={};')();
    console.log = (msg, ...params)=>{
        logMessage(joinConsoleMessage(msg, params));
    };
    console.warn = console.error = (msg, ...params)=>{
        logError(joinConsoleMessage(msg, params));
    };
    console.assert = (value, msg, ...params)=>{
        if (value) return;
        const joined = joinConsoleMessage(msg, params);
        logError(joined);
        debugger;
        throw Error('Assertion failed: '+joined);
    };
}
